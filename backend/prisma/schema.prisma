generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  SEEKER
  PROVIDER
  EMPLOYEE
  MANAGER
  ADMIN
  SUPER_ADMIN
}

enum VerificationStatus {
  PENDING
  IN_PROGRESS
  APPROVED
  REJECTED
}

enum BookingType {
  INCALL
  OUTCALL
}

enum BookingStatus {
  PENDING
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  DISPUTED
}

enum TokenTransactionType {
  PURCHASE
  BOOKING_PAYMENT
  BOOKING_REFUND
  ESCROW_HOLD
  ESCROW_RELEASE
  WITHDRAWAL
}

enum AssignmentType {
  VERIFICATION
  BOOKING_MONITORING
}

enum TemplateCategory {
  BOOKING_COORDINATION
  SERVICE_DISCUSSION
  LOGISTICS
  SUPPORT
  SYSTEM
}

enum DisputeType {
  NO_SHOW
  SERVICE_QUALITY
  PAYMENT_ISSUE
  BEHAVIOR_ISSUE
  TERMS_VIOLATION
  OTHER
}

enum DisputeStatus {
  OPEN
  INVESTIGATING
  RESOLVED
  CLOSED
  ESCALATED
}

enum TicketCategory {
  ACCOUNT
  BOOKING
  PAYMENT
  TECHNICAL
  VERIFICATION
  SAFETY
  OTHER
}

enum TicketPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum TicketStatus {
  OPEN
  IN_PROGRESS
  WAITING_USER
  RESOLVED
  CLOSED
}

enum ArticleCategory {
  GETTING_STARTED
  ACCOUNT
  BOOKINGS
  PAYMENTS
  SAFETY
  PROVIDERS
  FAQ
}

enum WithdrawalStatus {
  PENDING
  APPROVED
  PROCESSING
  COMPLETED
  REJECTED
  CANCELLED
}

enum PaymentMethodType {
  PAYPAL
  BANK_TRANSFER
  UPI
}

model User {
  id              String   @id @default(uuid())
  email           String   @unique
  phone           String?
  passwordHash    String
  role            UserRole @default(SEEKER)
  isVerified      Boolean  @default(false)
  isAgeVerified   Boolean  @default(false)
  isPhoneVerified Boolean  @default(false)
  isEmailVerified Boolean  @default(false)
  consentGiven    Boolean  @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Profile information
  profile     UserProfile?
  
  // Token wallet
  tokenWallet TokenWallet?
  
  // OTP verification
  otps        OTP[]
  
  // User bookings
  bookingsAsSeeker   Booking[] @relation("SeekerBookings")
  bookingsAsProvider Booking[] @relation("ProviderBookings")
  
  // Chat messages
  sentMessages     Message[] @relation("SentMessages")
  receivedMessages Message[] @relation("ReceivedMessages")
  
  // Token transactions
  tokenTransactions TokenTransaction[]

  // Chat templates created by admin
  createdTemplates ChatTemplate[]

  // Ratings
  ratingsGiven    Rating[] @relation("SeekerRatings")
  ratingsReceived Rating[] @relation("ProviderRatings")

  // Disputes
  disputesFiled    Dispute[] @relation("ReportedDisputes")
  disputesReceived Dispute[] @relation("ReceivedDisputes")
  disputesAssigned Dispute[] @relation("AssignedDisputes")

  // Support tickets
  supportTickets         SupportTicket[] @relation("UserTickets")
  assignedTickets        SupportTicket[] @relation("AssignedTickets")
  ticketMessages         TicketMessage[]

  // Help articles
  createdArticles  HelpArticle[]

  // Withdrawals
  paymentMethods   PaymentMethod[]
  withdrawalRequests WithdrawalRequest[]
  approvedWithdrawals WithdrawalRequest[] @relation("ApprovedWithdrawals")

  @@map("users")
}

model UserProfile {
  id          String   @id @default(uuid())
  userId      String   @unique
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  firstName   String?
  lastName    String?
  displayName String?
  age         Int?
  phoneNumber String?
  location    String?
  bio         String?
  profilePhoto String?
  
  // Provider-specific fields
  isProvider       Boolean @default(false)
  verificationStatus String @default("PENDING") // "PENDING", "APPROVED", "REJECTED"
  services         String? // JSON string of services
  hourlyRate       Int?     // in tokens
  availability     String?  // JSON availability schedule

  // Rating fields (for providers)
  averageRating    Float?   @default(0)
  totalRatings     Int      @default(0)
  ratingBreakdown  String?  // JSON with breakdown: {"5": 10, "4": 5, "3": 2, "2": 0, "1": 0}

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("profiles")
}

model OTP {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  code      String
  type      String   // "EMAIL_VERIFICATION", "PHONE_VERIFICATION", "PASSWORD_RESET"
  expiresAt DateTime
  verified  Boolean  @default(false)
  attempts  Int      @default(0)
  createdAt DateTime @default(now())
  
  @@map("otps")
}

model Booking {
  id          String        @id @default(uuid())
  seekerId    String
  providerId  String
  seeker      User          @relation("SeekerBookings", fields: [seekerId], references: [id])
  provider    User          @relation("ProviderBookings", fields: [providerId], references: [id])
  
  serviceType String        // "INCALL", "OUTCALL"
  status      String @default("PENDING") // "PENDING", "CONFIRMED", "IN_PROGRESS", "COMPLETED", "CANCELLED", "DISPUTED"
  
  scheduledAt DateTime
  duration    Int           // in minutes
  location    String?       // for outcall bookings
  
  tokenAmount Int           // tokens to be paid
  escrowHeld  Boolean       @default(false)
  
  // Chat for this booking
  chatId      String?       @unique
  chat        Chat?         @relation(fields: [chatId], references: [id])

  // Rating for this booking
  rating      Rating?

  // Disputes for this booking
  disputes    Dispute[]

  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  @@map("bookings")
}

model Chat {
  id          String    @id @default(uuid())
  
  // Participants (stored as JSON)
  participantIds String // JSON array of user IDs
  
  // Messages
  messages    Message[]
  
  // Associated booking (optional)
  booking     Booking?
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  @@map("chats")
}

model Message {
  id         String      @id @default(uuid())
  chatId     String
  chat       Chat        @relation(fields: [chatId], references: [id], onDelete: Cascade)

  senderId   String
  receiverId String
  sender     User        @relation("SentMessages", fields: [senderId], references: [id])
  receiver   User        @relation("ReceivedMessages", fields: [receiverId], references: [id])

  content    String
  type       String @default("TEXT") // "TEXT", "IMAGE", "FILE", "SYSTEM", "TEMPLATE"
  fileUrl    String?

  // Template-based messaging
  templateId String?
  template   ChatTemplate? @relation(fields: [templateId], references: [id])
  templateVariables String? // JSON object with variable values

  isRead     Boolean     @default(false)
  readAt     DateTime?

  createdAt  DateTime    @default(now())

  @@map("messages")
}

model TokenTransaction {
  id            String            @id @default(uuid())
  userId        String
  user          User              @relation(fields: [userId], references: [id])
  
  type          String            // "PURCHASE", "PAYMENT", "REFUND", "ESCROW_HOLD", "ESCROW_RELEASE"
  amount        Int               // tokens
  valueInr      Int               // equivalent INR value
  status        String @default("PENDING") // "PENDING", "COMPLETED", "FAILED", "CANCELLED"
  
  // Payment details
  paymentId     String?           // PayPal/Stripe payment ID
  paymentMethod String?           // "paypal", "stripe", etc.
  
  // Booking relation (for escrow)
  bookingId     String?
  
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  
  @@map("token_transactions")
}

model TokenWallet {
  id           String   @id @default(uuid())
  userId       String   @unique
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  balance      Int      @default(0)
  totalEarned  Int      @default(0)
  totalSpent   Int      @default(0)

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@map("token_wallets")
}

model ChatTemplate {
  id          String           @id @default(uuid())
  category    TemplateCategory
  templateText String
  description String?          // What this template is for
  variables   String[]         // Array of variable names like ["time", "location", "rate"]
  isActive    Boolean          @default(true)

  // Template management
  createdBy   String
  creator     User             @relation(fields: [createdBy], references: [id])

  // Usage tracking
  usageCount  Int              @default(0)

  // Messages using this template
  messages    Message[]

  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  @@map("chat_templates")
}

model Rating {
  id          String   @id @default(uuid())
  bookingId   String   @unique
  booking     Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  // Who rated
  seekerId    String
  seeker      User     @relation("SeekerRatings", fields: [seekerId], references: [id])

  // Who was rated
  providerId  String
  provider    User     @relation("ProviderRatings", fields: [providerId], references: [id])

  // Rating details
  rating      Int      // 1-5 stars
  review      String?  // Optional text review (max 500 chars)
  anonymous   Boolean  @default(false)

  // Provider response
  response    String?
  respondedAt DateTime?

  // Moderation
  isFlagged   Boolean  @default(false)
  flagReason  String?

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([providerId])
  @@index([createdAt])
  @@map("ratings")
}

model Dispute {
  id              String        @id @default(uuid())
  bookingId       String
  booking         Booking       @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  // Who filed the dispute
  reportedBy      String
  reporter        User          @relation("ReportedDisputes", fields: [reportedBy], references: [id])

  // Against whom
  reportedAgainst String
  reportedUser    User          @relation("ReceivedDisputes", fields: [reportedAgainst], references: [id])

  // Dispute details
  disputeType     DisputeType
  status          DisputeStatus @default(OPEN)
  description     String
  evidence        String[]      // Array of URLs to evidence (screenshots, photos, etc)

  // Resolution
  assignedTo      String?       // Manager/Admin handling the dispute
  assignedManager User?         @relation("AssignedDisputes", fields: [assignedTo], references: [id])
  resolution      String?
  resolvedAt      DateTime?

  // Outcome
  refundIssued    Boolean       @default(false)
  refundAmount    Int?          // tokens refunded
  actionTaken     String?       // Description of action taken

  // Appeal
  canAppeal       Boolean       @default(true)
  appealed        Boolean       @default(false)
  appealNotes     String?

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@index([bookingId])
  @@index([reportedBy])
  @@index([status])
  @@map("disputes")
}

model SupportTicket {
  id          String         @id @default(uuid())
  ticketNumber Int           @unique @default(autoincrement())

  // User who created the ticket
  userId      String
  user        User           @relation("UserTickets", fields: [userId], references: [id], onDelete: Cascade)

  // Ticket details
  subject     String
  description String
  category    TicketCategory
  priority    TicketPriority @default(MEDIUM)
  status      TicketStatus   @default(OPEN)

  // Assignment
  assignedTo  String?
  assignedUser User?         @relation("AssignedTickets", fields: [assignedTo], references: [id])
  assignedAt  DateTime?

  // Resolution
  resolvedAt  DateTime?
  closedAt    DateTime?
  resolution  String?

  // Related entities
  bookingId   String?        // Optional reference to a booking

  // Messages/replies
  messages    TicketMessage[]

  // Metadata
  userEmail   String?        // Store user email at time of ticket creation
  userPhone   String?
  attachments String[]       // Array of URLs

  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  @@index([userId])
  @@index([status])
  @@index([category])
  @@index([ticketNumber])
  @@map("support_tickets")
}

model TicketMessage {
  id        String        @id @default(uuid())
  ticketId  String
  ticket    SupportTicket @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  // Message sender
  senderId  String
  sender    User          @relation(fields: [senderId], references: [id])
  isStaff   Boolean       @default(false) // true if sent by support staff

  // Message content
  message   String
  attachments String[]    // Array of URLs

  // Internal note (only visible to staff)
  isInternal Boolean      @default(false)

  createdAt DateTime     @default(now())

  @@index([ticketId])
  @@map("ticket_messages")
}

model HelpArticle {
  id          String          @id @default(uuid())
  slug        String          @unique

  // Content
  title       String
  content     String          // Markdown content
  excerpt     String?         // Short description
  category    ArticleCategory

  // Meta
  featured    Boolean         @default(false)
  published   Boolean         @default(false)
  viewCount   Int             @default(0)
  helpfulCount Int            @default(0)

  // Search optimization
  tags        String[]        // Array of tags for search
  searchTerms String?         // Additional search keywords

  // Author
  authorId    String
  author      User            @relation(fields: [authorId], references: [id])

  // Related articles
  relatedArticles String[]     // Array of article IDs

  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  publishedAt DateTime?

  @@index([category])
  @@index([published])
  @@index([slug])
  @@map("help_articles")
}

model PaymentMethod {
  id          String            @id @default(uuid())
  userId      String
  user        User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Payment method details
  type        PaymentMethodType
  isDefault   Boolean           @default(false)
  isVerified  Boolean           @default(false)

  // PayPal
  paypalEmail String?

  // Bank Transfer
  accountHolderName String?
  accountNumber     String?
  ifscCode          String?
  bankName          String?
  branchName        String?

  // UPI
  upiId       String?

  // Metadata
  nickname    String?           // e.g., "My PayPal Account", "SBI Savings"

  // Withdrawals using this method
  withdrawals WithdrawalRequest[]

  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  @@index([userId])
  @@index([type])
  @@map("payment_methods")
}

model WithdrawalRequest {
  id              String           @id @default(uuid())
  requestNumber   Int              @unique @default(autoincrement())

  // Provider requesting withdrawal
  userId          String
  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Amount
  amountTokens    Int              // Amount in tokens
  amountInr       Int              // Equivalent INR (tokens * 100)
  processingFee   Int              @default(0) // Platform fee
  netAmount       Int              // Amount after fee

  // Payment method
  paymentMethodId String
  paymentMethod   PaymentMethod    @relation(fields: [paymentMethodId], references: [id])

  // Status
  status          WithdrawalStatus @default(PENDING)

  // Admin approval
  approvedBy      String?
  approvedByUser  User?            @relation("ApprovedWithdrawals", fields: [approvedBy], references: [id])
  approvedAt      DateTime?
  rejectionReason String?

  // Processing
  processedAt     DateTime?
  transactionId   String?          // External payment ID (PayPal, bank reference, etc.)

  // Notes
  providerNotes   String?
  adminNotes      String?

  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  @@index([userId])
  @@index([status])
  @@index([requestNumber])
  @@map("withdrawal_requests")
}
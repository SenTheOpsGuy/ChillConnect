generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id          String   @id @default(uuid())
  email       String   @unique
  password    String
  role        UserRole @default(USER)
  isVerified  Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Profile information
  profile     Profile?
  
  // OTP verification
  otps        OTP[]
  
  // User bookings
  bookingsAsSeeker   Booking[] @relation("SeekerBookings")
  bookingsAsProvider Booking[] @relation("ProviderBookings")
  
  // Chat messages
  sentMessages     Message[] @relation("SentMessages")
  receivedMessages Message[] @relation("ReceivedMessages")
  
  // Token transactions
  tokenTransactions TokenTransaction[]
  walletBalance     Int @default(0)
  
  // Admin assignments
  adminAssignments AdminAssignment[]
  
  @@map("users")
}

model Profile {
  id          String   @id @default(uuid())
  userId      String   @unique
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  firstName   String?
  lastName    String?
  displayName String?
  age         Int?
  phoneNumber String?
  location    String?
  bio         String?
  profilePhoto String?
  
  // Provider-specific fields
  isProvider       Boolean @default(false)
  verificationStatus VerificationStatus @default(PENDING)
  services         String[] // JSON array of services
  hourlyRate       Int?     // in tokens
  availability     String?  // JSON availability schedule
  
  // Documents
  documents        Document[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@map("profiles")
}

model OTP {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  code      String
  type      OTPType
  expiresAt DateTime
  verified  Boolean  @default(false)
  attempts  Int      @default(0)
  createdAt DateTime @default(now())
  
  @@map("otps")
}

model Document {
  id          String     @id @default(uuid())
  profileId   String
  profile     Profile    @relation(fields: [profileId], references: [id], onDelete: Cascade)
  type        DocumentType
  filename    String
  originalName String
  mimeType    String
  size        Int
  url         String?
  status      VerificationStatus @default(PENDING)
  uploadedAt  DateTime   @default(now())
  verifiedAt  DateTime?
  
  @@map("documents")
}

model Booking {
  id          String        @id @default(uuid())
  seekerId    String
  providerId  String
  seeker      User          @relation("SeekerBookings", fields: [seekerId], references: [id])
  provider    User          @relation("ProviderBookings", fields: [providerId], references: [id])
  
  serviceType BookingType
  status      BookingStatus @default(PENDING)
  
  scheduledAt DateTime
  duration    Int           // in minutes
  location    String?       // for outcall bookings
  
  tokenAmount Int           // tokens to be paid
  escrowHeld  Boolean       @default(false)
  
  // Chat for this booking
  chatId      String?       @unique
  chat        Chat?         @relation(fields: [chatId], references: [id])
  
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  
  @@map("bookings")
}

model Chat {
  id          String    @id @default(uuid())
  
  // Participants
  participantIds String[] // Array of user IDs
  
  // Messages
  messages    Message[]
  
  // Associated booking (optional)
  booking     Booking?
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  @@map("chats")
}

model Message {
  id         String      @id @default(uuid())
  chatId     String
  chat       Chat        @relation(fields: [chatId], references: [id], onDelete: Cascade)
  
  senderId   String
  receiverId String
  sender     User        @relation("SentMessages", fields: [senderId], references: [id])
  receiver   User        @relation("ReceivedMessages", fields: [receiverId], references: [id])
  
  content    String
  type       MessageType @default(TEXT)
  fileUrl    String?
  
  isRead     Boolean     @default(false)
  readAt     DateTime?
  
  createdAt  DateTime    @default(now())
  
  @@map("messages")
}

model TokenTransaction {
  id            String            @id @default(uuid())
  userId        String
  user          User              @relation(fields: [userId], references: [id])
  
  type          TransactionType
  amount        Int               // tokens
  valueInr      Int               // equivalent INR value
  status        TransactionStatus @default(PENDING)
  
  // Payment details
  paymentId     String?           // PayPal/Stripe payment ID
  paymentMethod String?           // "paypal", "stripe", etc.
  
  // Booking relation (for escrow)
  bookingId     String?
  
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt
  
  @@map("token_transactions")
}

model AdminAssignment {
  id         String          @id @default(uuid())
  employeeId String
  employee   User            @relation(fields: [employeeId], references: [id])
  
  type       AssignmentType
  status     AssignmentStatus @default(ACTIVE)
  
  // Assignment details (JSON)
  details    String?         // JSON with task-specific data
  
  assignedAt DateTime        @default(now())
  completedAt DateTime?
  
  @@map("admin_assignments")
}

// Enums
enum UserRole {
  USER
  ADMIN
  EMPLOYEE
  SUPER_ADMIN
}

enum VerificationStatus {
  PENDING
  APPROVED
  REJECTED
}

enum OTPType {
  EMAIL_VERIFICATION
  PHONE_VERIFICATION
  PASSWORD_RESET
}

enum DocumentType {
  GOVERNMENT_ID
  PROOF_OF_ADDRESS
  PROFILE_PHOTO
  ADDITIONAL_VERIFICATION
}

enum BookingType {
  INCALL
  OUTCALL
}

enum BookingStatus {
  PENDING
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  DISPUTED
}

enum MessageType {
  TEXT
  IMAGE
  FILE
  SYSTEM
}

enum TransactionType {
  PURCHASE
  PAYMENT
  REFUND
  ESCROW_HOLD
  ESCROW_RELEASE
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
}

enum AssignmentType {
  VERIFICATION_QUEUE
  BOOKING_MONITORING
  CUSTOMER_SUPPORT
}

enum AssignmentStatus {
  ACTIVE
  COMPLETED
  PAUSED
}
